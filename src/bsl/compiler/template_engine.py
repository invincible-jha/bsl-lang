"""Template engine for BSL compiler output files.

Uses Python f-strings and string operations — no Jinja2 dependency.
All public functions return complete, syntactically valid Python source
strings ready to be written to disk.
"""
from __future__ import annotations

import re
import textwrap
from datetime import datetime, timezone
from typing import Sequence


# ---------------------------------------------------------------------------
# File-level templates
# ---------------------------------------------------------------------------

_FILE_HEADER = """\
# Generated by BSL compiler — do not edit manually.
# Source agent : {agent_name}
# BSL version  : {bsl_version}
# Target       : pytest
# Generated at : {generated_at}
"""

_IMPORTS_BLOCK = """\
from __future__ import annotations

import re
from typing import Any

import pytest
"""

_TEMPORAL_HELPERS = """\
# ---------------------------------------------------------------------------
# Temporal-ordering helpers (BSL before/after operators)
# ---------------------------------------------------------------------------


def _bsl_before(left: object, right: object) -> bool:
    \"\"\"Return True when left precedes right in evaluation order.\"\"\"
    try:
        return bool(left) < bool(right)
    except TypeError:
        return False


def _bsl_after(left: object, right: object) -> bool:
    \"\"\"Return True when left follows right in evaluation order.\"\"\"
    try:
        return bool(left) > bool(right)
    except TypeError:
        return False
"""

_MODULE_DOCSTRING = '''\
"""Pytest test suite generated from BSL agent specification: {agent_name}.

Each test function corresponds to one invariant, behavior constraint, or
boundary condition declared in the BSL source.  Tests are parameterized
where the BSL spec provides multiple constraint expressions.

Do **not** edit this file — regenerate it from the BSL source instead.
"""
'''


def render_file_header(
    agent_name: str,
    bsl_version: str | None,
    generated_at: datetime | None = None,
) -> str:
    """Render the file header comment block.

    Parameters
    ----------
    agent_name:
        The BSL agent identifier (e.g. ``"CustomerServiceAgent"``).
    bsl_version:
        The BSL spec version string, or ``None`` if not specified.
    generated_at:
        UTC timestamp for the generation time.  Defaults to now.

    Returns
    -------
    str
        A multi-line comment block (no trailing newline).
    """
    ts = (generated_at or datetime.now(tz=timezone.utc)).strftime(
        "%Y-%m-%dT%H:%M:%SZ"
    )
    return _FILE_HEADER.format(
        agent_name=agent_name,
        bsl_version=bsl_version or "unversioned",
        generated_at=ts,
    )


def render_module_docstring(agent_name: str) -> str:
    """Render the module-level docstring.

    Parameters
    ----------
    agent_name:
        The BSL agent identifier.

    Returns
    -------
    str
        A triple-quoted docstring (includes trailing newline).
    """
    return _MODULE_DOCSTRING.format(agent_name=agent_name)


def render_imports(needs_temporal_helpers: bool = False) -> str:
    """Render the import block.

    Parameters
    ----------
    needs_temporal_helpers:
        When ``True``, append the ``_bsl_before`` / ``_bsl_after``
        helper function definitions after the import block.

    Returns
    -------
    str
        Import statements and optional helpers.
    """
    parts = [_IMPORTS_BLOCK]
    if needs_temporal_helpers:
        parts.append(_TEMPORAL_HELPERS)
    return "\n".join(parts)


# ---------------------------------------------------------------------------
# Fixture block
# ---------------------------------------------------------------------------


def render_agent_fixture(agent_name: str, fields: dict[str, str]) -> str:
    """Render a pytest fixture that provides a simple mock agent context.

    Parameters
    ----------
    agent_name:
        The BSL agent identifier.
    fields:
        A mapping of field name → default Python value string used to
        populate the fixture's mock object, e.g.
        ``{"response": '"Hello"', "status": "200"}``.

    Returns
    -------
    str
        A complete ``@pytest.fixture`` function definition.
    """
    fixture_name = _to_snake_case(agent_name) + "_context"
    field_lines = "\n".join(
        f"    ctx.{name} = {value}" for name, value in sorted(fields.items())
    )
    return textwrap.dedent(f"""\
        class _AgentContext:
            \"\"\"Minimal mock context for {agent_name} tests.\"\"\"
            def __init__(self) -> None:
                pass

            def __setattr__(self, name: str, value: Any) -> None:
                object.__setattr__(self, name, value)

            def __getattr__(self, name: str) -> Any:  # noqa: ANN401
                return None


        @pytest.fixture()
        def {fixture_name}() -> _AgentContext:
            \"\"\"Provide a default mock context for {agent_name}.\"\"\"
            ctx = _AgentContext()
        {field_lines if field_lines else "    pass"}
            return ctx
    """)


# ---------------------------------------------------------------------------
# Test function block
# ---------------------------------------------------------------------------


def render_test_function(
    test_name: str,
    docstring: str,
    fixture_names: Sequence[str],
    body_lines: Sequence[str],
    markers: Sequence[str] | None = None,
) -> str:
    """Render a complete pytest test function.

    Parameters
    ----------
    test_name:
        The Python function name (must start with ``test_``).
    docstring:
        One-line description for the function docstring.
    fixture_names:
        Names of pytest fixtures to inject as parameters.
    body_lines:
        Lines of the function body (assertions, setup).
    markers:
        Optional ``@pytest.mark.*`` decorator strings (without the ``@``).

    Returns
    -------
    str
        A complete function definition including decorators.
    """
    decorator_lines = [f"@{marker}" for marker in (markers or [])]
    params = ", ".join(fixture_names)
    body = "\n".join(f"    {line}" for line in body_lines) if body_lines else "    pass"
    decorators = "\n".join(decorator_lines) + "\n" if decorator_lines else ""
    # Sanitize the docstring to avoid breaking the triple-quote delimiter.
    safe_docstring = docstring.replace('"""', "'''")
    return (
        f"{decorators}def {test_name}({params}) -> None:\n"
        f'    """{safe_docstring}"""\n'
        f"{body}\n"
    )


def render_parametrize_decorator(
    argname: str,
    values: Sequence[str],
) -> str:
    """Render a ``@pytest.mark.parametrize`` decorator string.

    Parameters
    ----------
    argname:
        The parameter name that pytest will inject.
    values:
        The list of test values as Python repr strings.

    Returns
    -------
    str
        E.g. ``'pytest.mark.parametrize("value", ["a", "b"])'``
    """
    values_repr = "[" + ", ".join(values) + "]"
    return f'pytest.mark.parametrize("{argname}", {values_repr})'


# ---------------------------------------------------------------------------
# Section separator
# ---------------------------------------------------------------------------


def render_section_separator(title: str) -> str:
    """Render a section comment separator.

    Parameters
    ----------
    title:
        Short title for the section.

    Returns
    -------
    str
        A 79-character comment line.
    """
    bar = "-" * 75
    return f"# {bar}\n# {title}\n# {bar}\n"


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _to_snake_case(name: str) -> str:
    """Convert a CamelCase or PascalCase name to snake_case.

    Parameters
    ----------
    name:
        E.g. ``"CustomerServiceAgent"``

    Returns
    -------
    str
        E.g. ``"customer_service_agent"``
    """
    # Insert underscore before each uppercase letter that follows a
    # lowercase letter or digit.
    result = re.sub(r"(?<=[a-z0-9])([A-Z])", r"_\1", name)
    return result.lower()


def sanitize_identifier(name: str) -> str:
    """Convert a BSL identifier into a valid Python identifier.

    Replaces non-alphanumeric characters with underscores and ensures
    the result does not start with a digit.

    Parameters
    ----------
    name:
        A BSL name, e.g. ``"safe-communication"`` or ``"pii_protection"``.

    Returns
    -------
    str
        A valid Python identifier.
    """
    cleaned = re.sub(r"[^a-zA-Z0-9_]", "_", name)
    if cleaned and cleaned[0].isdigit():
        cleaned = "_" + cleaned
    return cleaned
